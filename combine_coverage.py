import argparse
from pathlib import Path

from defusedxml import ElementTree


def parse_coverage_xml(path: str) -> dict[str, int]:
    """
    Parses the xml file created by pytest coverage command and calculates covered lines in each file

    Args:
        path(str): path to coverage xml file

    Returns: dictionary of covered lines for each file

    """
    covered_lines_dict = {}
    total_lines_dict1 = {}

    tree = ElementTree.parse(path)
    root = tree.getroot()

    for package in root.findall(".//package"):
        for clazz in package.findall("classes/class"):
            filename = clazz.attrib["filename"]
            covered_lines_dict[filename] = []

            total_lines = 0
            for line in clazz.findall("lines/line"):
                line_number = line.attrib["number"]
                hits = line.attrib["hits"]
                if hits != "0":
                    covered_lines_dict[filename].append(line_number)

                total_lines += 1

            total_lines_dict1[filename] = total_lines

    return covered_lines_dict, total_lines_dict1


def main(list_of_path: list, directory_path: str) -> None:
    """
    Prints combined coverage by calculating total lines in diresctory and coveread lines from two pytest coverage file.

    Args:
        path1(str): path to coverage xml file
        path2(str): path to coverage xml file
        directory_path(str): path to directorey file over which is coverage is calculated

    Returns:
        None
    """

    total_coverage = {}
    total_lines = {}
    total_covered_lines = 0
    total_lines_lines = 0
    # parses each xml file and merges the coverage dictionary into global dictionary
    for path in list_of_path:
        if not Path(path).exists():
            raise FileNotFoundError(f"file in {path} does not exist")

        covered_lines_dict, total_lines_dict = parse_coverage_xml(path)

        # Check for filename in merged dictionary, if exists add unique lines, if not then added the filename
        for key, values in covered_lines_dict.items():
            if key in total_coverage:
                # only keeps unique covered lines for each file in code base
                total_coverage[key] = list(set(values + total_coverage[key]))
            else:
                total_coverage[key] = values
                total_lines[key] = total_lines_dict[key]

    for key in total_coverage:
        total_covered_lines += len(total_coverage[key])

    for key in total_lines:
        total_lines_lines += total_lines[key]

    print(
        f"TOTAL  {total_lines_lines}   {total_covered_lines}   {round((total_covered_lines / total_lines_lines) * 100)}"
    )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="A simple script that takes arguments.")
    parser.add_argument(
        "--list_of_path", type=list[str], help="Takes paths to .xml files generated by pytest coverage"
    )
    parser.add_argument("--dir", type=str, help="source directory to calculate total lines in code base")

    args = parser.parse_args()

    list_of_path = "".join(args.list_of_path).lstrip("[").rstrip("]").split(",")
    main(list_of_path, args.dir)
